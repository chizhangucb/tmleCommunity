% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GenericModelClasses.R
\docType{class}
\name{RegressionClass}
\alias{RegressionClass}
\title{R6 class for defining regression models that evaluate multivariate joint conditional density \eqn{P(A|W,E)} 
 (or \eqn{P(A|W)} if non-hierarchical structure)}
\format{An \code{\link{R6Class}} generator object}
\usage{
RegressionClass
}
\description{
\code{RegressionClass} provides multiple options used when estimating a conditional density \eqn{P(A|W,E)}. \code{A} 
 can be multivariate, if so, hazard specification will factorize \code{P(A|W,E)} = \code{P(A[1],..., } \code{A[M]|W,E)} as a 
 sequence \code{P(A[1]|W,E)} * \code{P(A[2]|W, E, A[1])} * ... * \code{P(A[M]|W, E, A[1],...,}  \code{A[M-1])}, where each of the 
 compoenents \code{A[m]} can be either binary, categorical or continuous, and each of the conditional densities 
 \code{P(A[m]|W, E, A[1],...,A[m-1])} will be controlled  by a new instance of \code{\link{GenericModel}} class. If \code{A[m]}
 binary, \code{P(A[m]|W, E, A[1],...,A[m-1])} will be esimtated by a user-specific library of candidate algorithms, including 
 parametric estimators such as logistic model with only main terms, and data-adaptive estimator such as super-learner algorithms. 
 If \code{A[m]} continuous (or categorical), \code{P(A[m]|W, E, A[1],...,A[m-1])} will then be controlled by a new instance of 
 \code{\link{ContinModel}} class (or \code{\link{CategorModel}} class). Note that each \code{GenericModel}, \code{ContinModel} 
 and \code{CategorModel} class will accompany with an adjunctive clone of a parent \code{RegressionClass} class. The automatically 
 recursive process of defining new instances of \code{GenericModel} and cloning \code{RegressionClass} classes won't stop until 
 the entire sequence of binary regressions that represents \code{P(A|W,E)} is constructed.
}
\details{
\itemize{
\item{\code{outvar.class}} - Character vector of outcome variable classes (of length(outvar)): one of \code{bin}, \code{cont}, \code{cat}.
\item{\code{outvar}} - Character vector of regression outcome variable names.
\item{\code{predvars}} - Character vector of regression-specific predictor names or a pool of all available predictor names.
\item{{reg_hazard}} - Logical, hazard fitting method. If TRUE, factorize P(outvar | predvars) into \\prod_{j}{P(outvar[j] | predvars)} for each j.
\item{\code{subset_vars}} - Named list for subset variables/ expression (later converted to logical vector).
\item{\code{ReplMisVal0}} - Logical. If TRUE, user-supplied gvars$misXreplace (Default to 0) will be used to replace all gvars$misval 
  among predictors (Default to TRUE).
\item{\code{nbins}} - Number of bins used for estimation of a continuous outvar, defined in ContinModel$new().
\item{\code{estimator}} - Character, one of "speedglm__glm" (default), "glm__glm", "h2o__ensemble", "SuperLearner". The estimator for which to fit 
  regression model. For "h2o__ensemble" and "SuperLearner", users can specify the data-adaptive algorithms through \code{tmleCom_Options}.
\item{\code{parfit}} - Logical. If TRUE, use parallel computing on binary regressions. See \code{foreach::foreach}.
\item{\code{pool_cont}} - Logical. If TRUE, pool over bins of a continuous outvar and fit one regression, along with bin_ID as an extra variable. 
\item{\code{outvars_to_pool}} - Character vector of bin names of a continuous outvars, should be identical to \code{bin_nms}.
\item{\code{intrvls}} - Numeric vector defining the number and positions of the bins or a named list of numeric vectors if 2 or more outvars.
  If not specified and outvar continuous, intervals will be determined in \code{ContinModel} through \code{DatKeepClass$detect.sVar.intrvls}.
\item{\code{intrvls.width}} - Named numeric vector of bin widths for each bin in \code{self$intrvls}. If not specified, default to 1 if
  outvar binary, default to \code{diff(self$intrvls)} if outvar continuous, 
}
}
\section{Methods}{

\describe{
  \item{\code{new(outvar.class = gvars$sVartypes$bin, outvar, predvars, subset_vars, intrvls,
                  ReplMisVal0 = TRUE, estimator = getopt("Qestimator"), parfit = getopt("parfit"),
                  pool_cont = getopt("poolContinVar")}}{Instantiate an new instance of \code{RegressionClass}} 
  \item{\code{ChangeManyToOneRegresssion(k_i, reg)}}{Clone the parent \code{RegressionClass} (\code{reg}) that include \code{length(self$outvar)} 
  regressions, and reset self to a single univariate \code{k_i} regression for outcome \code{self$outvar[[k_i]]}.}
  \item{\code{resetS3class()}}{Reset the object class to "RegressionClass" and "R6".}
}
}

\section{Active Bindings}{

\describe{
  \item{\code{S3class(newclass)}}{...}
  \item{\code{get.reg}}{...}
}
}

\examples{
data(indSample.iid.cA.bY_list)
indSample.iid.cA.bY <- indSample.iid.cA.bY_list$indSample.iid.cA.bY
nodes <- list(Ynode = "Y", Anodes = "A", WEnodes = c("W1", "W2", "W3", "W4"))
tmleCom_Options(maxNperBin = nrow(indSample.iid.cA.bY))

OData.g0 <- DatKeepClass$new(Odata = indSample.iid.cA.bY, nodes = nodes)
h.g0.sVars <- define_regform(A ~ W1 + W2 + W3 + W4) 
A.nms.g0 <- h.g0.sVars$outvars
regclass.g0 <- RegressionClass$new(outvar = A.nms.g0, predvars = h.g0.sVars$predvars,
                                   subset_vars = lapply(A.nms.g0, function(var) {var}),
                                   outvar.class = OData.g0$type.sVar[A.nms.g0])
regclass.g0$estimator  # "speedglm__glm"
regclass.g0$pool_cont  # FALSE (Don't pool across all bins of a continuous exposure)
regclass.g0$parfit     # FALSE (Don't preform parallel computing in estimation)

# Clone the parent regclass.g0 and reset to a single univariate k_i regression 
# for outcome regclass.g0$outvar[[k_i]]
k_i <- 1
reg_i <- regclass.g0$clone()
reg_i$ChangeManyToOneRegresssion(k_i, regclass.g0)
genericmodels.g0.A1 <- ContinModel$new(reg = reg_i, DatKeepClass.g0 = OData.g0)
}
\seealso{
\code{\link{DatKeepClass}}, \code{\link{GenericModel}}, \code{\link{ContinModel}}, \code{\link{CategorModel}}
}
\keyword{R6}
\keyword{class}
