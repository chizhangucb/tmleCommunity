% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BinaryOutModelClass.R
\docType{class}
\name{BinaryOutModel}
\alias{BinaryOutModel}
\title{R6 class for modeling (fitting and predicting) for a single binary regression model P(B | PredVars)}
\format{An \code{\link{R6Class}} generator object}
\usage{
BinaryOutModel
}
\description{
\code{BinaryOutModel} can store and manage the (binarize/ discretized) design matrix Xmat and the outcome Bin for the binary regression 
 P(Bin|Xmat). It provides argument \code{self$estimator} to include different candidate estimators in the fitting and predicting library,  
 such as data-adaptive super learner algorithms and parametric logistic regression. When fitting one pooled regression across multiple 
 bins, it provides method to convert data from wide to long format when requested (to gain computational efficiency).
}
\details{
\itemize{
\item{bin_names} - Character vector of names of the bins.
\item{ID} - Integer vector of observation IDs used for pooling. \code{1:n}.
\item{pooled_bin_name} - Original name of the continuous covariate that was discretized into bins and then pooled.
\item{nbins} - Number of bins used for estimation of a continuous outvar, defined in ContinModel$new().
\item{estimator} - Character, one of "speedglm__glm" (default), "glm__glm", "h2o__ensemble", "SuperLearner".
\item{outvar} - Character, outcome name.
\item{predvars} - Character vector of predictor names.
\item{cont.sVar.flag} - Logical. If TRUE, indicate the original outcome variable is continuous.
\item{bw.j} - Bin width of a bin indicator obtained from the discretization of a continous covariate.
\item{is.fitted} - Logical. If TRUE, indicate the \code{BinaryOutModel} class object is fitted already.
\item{pool_cont} - Logical. If TRUE, perform pooling of bins.
\item{outvars_to_pool} - Character vector of outcome bin names for pooling.
\item{ReplMisVal0} - Logical. If TRUE, user-supplied gvars$misXreplace (Default to 0) will be used to replace all gvars$misval 
  among predictors. \code{ReplMisVal0} in \code{RegressionClass} will be used when instantiating an new object of \code{BinaryOutModel}. 
\item{n} - Number of rows in the input data.
\item{subset_expr} - Vector of length \code{n} that specifies a subset of data to be used in the fitting process. 
  Either logical, expression or indices.
\item{subset_idx} - Logical version of \code{subset_expr}. 
}
}
\section{Methods}{

\describe{
  \item{\code{new(reg)}}{Use \code{reg} (a \code{\link{RegressionClass}} class object) to instantiate an new object of \code{BinaryOutModel} 
    for a single binary regression.}
  \item{\code{newdata(newdata, getoutvar = TRUE, ...)}}{Evaluate subset and perform correct subseting of data to construct 
    X_mat, Yvals & wt_vals.}
  \item{\code{define.subset.idx(data)}}{Create a logical vector which is converted from subset_expr}
  \item{\code{fit(overwrite = FALSE, data, predict = FALSE, savespace = TRUE, ...)}}{fit a binary regression. Note that \code{overwrite} is 
    Logical. If \code{FALSE} (Default), the previous fitted model cannot be overwritten by new fitting model. \code{savespace} is Logical. 
    If \code{TRUE} (Default), wipe out all internal data when doing many stacked regressions.}
  \item{\code{copy.fit(bin.out.model)}}{Take fitted BinaryOutModel object as an input and save the fit to itself.}
  \item{\code{predict(newdata, savespace = TRUE, ...)}}{Predict the response P(A = 1|W = w, E = e).}
  \item{\code{copy.predict(bin.out.model)}}{Tke BinaryOutModel object that contains the predictions for P(A=1|w,e) and save to itself}
  \item{\code{predictAeqa(newdata, bw.j.sA_diff, savespace = TRUE, wipeProb = TRUE)}}{Predict the response P(A = a|W = w, E = e) for 
    observed A, W, E. Note that wipeProb is logical argument for self$wipe.alldat. If FALSE, vectors of probA1 & probAeqa will be kept.}
  \item{\code{show()}}{Print regression formula, including outcome and predictor names.}
}
}

\section{Active Bindings}{

\describe{
  \item{\code{wipe.alldat(wipeProb = TRUE)}}{...}
  \item{\code{getfit}}{...}
  \item{\code{getprobA1}}{...}
  \item{\code{getprobAeqa}}{...}
  \item{\code{emptydata}}{...}
  \item{\code{emptyY}}{...}
  \item{\code{emptyWeight}}{...}
  \item{\code{emptySubset_idx}}{...}
  \item{\code{getXmat}}{...}
  \item{\code{getY}}{...}
  \item{\code{getWeight}}{...}
}
}

\examples{
#***************************************************************************************
# Example 1: Estimate a outcome regression directly through BinaryOutModel
data(indSample.iid.bA.bY.rareJ2_list)
indSample.iid.bA.bY.rareJ2 <- indSample.iid.bA.bY.rareJ2_list$indSample.iid.bA.bY.rareJ2
N <- nrow(indSample.iid.bA.bY.rareJ2)
# speed.glm to fit regressions (it's GLMs to medium-large datasets)
tmleCom_Options(Qestimator = "speedglm__glm", maxNperBin = N)
# gvars$verbose <- TRUE  # Print status messages (global setting)
#***************************************************************************************

#***************************************************************************************
# 1.1 Specifying outcome and predictor variables for outcome mechanism
#***************************************************************************************
# Y depends on all its parent nodes (A, W1, W2, W3, W4) 
Qform.all <- Y ~ W1 + W2 + W3 + W4 + A
Q.sVars1 <- define_regform(regform = Qform.all)

# Equivalent way to define Q.sVars: use Anodes.lst (outcomes) & Wnodes.lst (predictors)
# node can only contain one or more of Ynode, Anodes, WEnodes, communityID and Crossnodes
nodes <- list(Ynode = "Y", Anodes = "A", WEnodes = c("W1", "W2", "W3", "W4"))
Q.sVars2 <- define_regform(regform = NULL, Anodes.lst = nodes$Ynode, 
                           Wnodes.lst = nodes[c("Anodes", "WEnodes")])

# Also allows to include interaction terms in regression formula  (Correct Qform)
Qform.interact <- Y ~ W1 + W2*A + W3 + W4
Q.sVars3 <- define_regform(regform = Qform.interact)

# Alternative way to define Qform.interact 
Qform.interact2 <- Y ~ W1 + W2 + W3 + W4 + A + W2:A
Q.sVars4 <- define_regform(regform = Qform.interact2)

#***************************************************************************************
# 1.2 Fit and predict a regression model for outcome mechanism Qbar(A, W)
#***************************************************************************************
# Create a new object of DatKeepClass that can store and munipulate the input data
OData_R6 <- DatKeepClass$new(Odata = indSample.iid.bA.bY.rareJ2, 
                             nodes = nodes, norm.c.sVars = FALSE)
# Add a vector of observation (sampling) weights that encodes knowledge of rare outcome
OData_R6$addObsWeights(obs.wts = indSample.iid.bA.bY.rareJ2_list$obs.wt.J2)

# Create a new object of RegressionClass that defines regression models
# using misspecified Qform (without interaction term) 
Qreg <- RegressionClass$new(outvar = Q.sVars1$outvars, predvars = Q.sVars1$predvars, 
                            subset_vars = (!rep_len(FALSE, N)))

# Set savespace=FALSE to save all productions during fitting, including models and data
m.Q.init <- BinaryOutModel$new(reg = Qreg)$fit(data = OData_R6, savespace = FALSE)
length(m.Q.init$getY)  # 3000, the outcomes haven't been erased since savespace = FALSE
head(m.Q.init$getXmat)  # the predictor matrix is kept since savespace = FALSE
m.Q.init$getfit$coef  # Provide cofficients from the fitting regression
m.Q.init$is.fitted  # TRUE

# Now fit the same regression model but set savespace to TRUE (only fitted model left)
# Need to set overwrite to TRUE to avoid error when m.Q.init is already fitted
m.Q.init <- m.Q.init$fit(overwrite = TRUE, data = OData_R6, savespace = TRUE)
all(is.null(m.Q.init$getXmat), is.null(m.Q.init$getY))  # TRUE, all wiped out

# Set savespace = TRUE to wipe out any traces of saved data in predict step
m.Q.init$predict(newdata = OData_R6, savespace = TRUE)
is.null(m.Q.init$getXmat)  # TRUE, the covariates matrix has been erased to save RAM space
mean(m.Q.init$getprobA1)  # 0.02175083, bad estimate since misspecified Qform

#***************************************************************************************
# 1.3 Same as above but using Super Learner (data-adaptive algorithms)
#***************************************************************************************
# Instead of starting over from tmleCom_Options(), there is a more direct way to 
# specify the estimator used in Qreg and SuperLearner library
Qreg$estimator <- "SuperLearner"
# Another way to specify the prediction algorithms in SL library
gvars$opts$g.SL.library <- c("SL.glm", "SL.glm.interaction", "SL.randomForest")

set.seed(12345)
library(SuperLearner)
m.Q.init <- BinaryOutModel$new(reg = Qreg)$fit(data = OData_R6, savespace = TRUE)
m.Q.init$predict(newdata = OData_R6, savespace = TRUE)
mean(m.Q.init$getprobA1)
}
\seealso{
\code{\link{DatKeepClass}}, \code{\link{RegressionClass}}, \code{\link{tmleCom_Options}}
}
\keyword{R6}
\keyword{class}
